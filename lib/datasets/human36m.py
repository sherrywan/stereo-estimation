import os
from collections import defaultdict
import pickle

import numpy as np
import cv2

import torch
from torch.utils.data import Dataset

from lib.utils.camera import Camera
from lib.utils import multiview
from lib.utils.img import get_square_bbox, resize_image, crop_image, normalize_image, scale_bbox
from lib.utils import volumetric, op
from lib.datasets import body_kinematic


class Human36MMultiViewDataset(Dataset):
    """
        Human3.6M for multiview tasks.
    """
    def __init__(
            self,
            h36m_root='/Vol1/dbstore/datasets/Human3.6M/processed/',
            labels_path='/Vol1/dbstore/datasets/Human3.6M/extra/human36m-multiview-labels-SSDbboxes.npy',
            depths_label="/data0/wxy/stereo_matching/aanet_wxy/res/z_pred.npy",
            depthmaps_label="/data0/wxy/stereo_matching/aanet_wxy/res/z_map.npy",
            pred_results_path=None,
            image_shape=(256, 256),
            heatmap_shape=(96, 96),
            train=False,
            test=False,
            retain_every_n_frames_in_test=1,
            with_damaged_actions=True,
            cuboid_side=2000.0,
            scale_bbox=1.5,
            norm_image=True,
            kind="mpii",
            undistort_images=True,
            ignore_cameras=[],
            crop=True,
            action=None,
            dataset="h36m",
            rectificated=True,
            withsilhouette=True):
        """
            h36m_root:
                Path to 'processed/' directory in Human3.6M
            labels_path:
                Path to 'human36m-multiview-labels.npy' generated by 'generate-labels-npy-multiview.py'
                from https://github.sec.samsung.net/RRU8-VIOLET/human36m-preprocessing
            retain_every_n_frames_in_test:
                By default, there are 159 181 frames in training set and 26 634 in test (val) set.
                With this parameter, test set frames will be evenly skipped frames so that the
                test set size is `26634 // retain_every_n_frames_test`.
                Use a value of 13 to get 2049 frames in test set.
            with_damaged_actions:
                If `True`, will include 'S9/[Greeting-2,SittingDown-2,Waiting-1]' in test set.
            kind:
                Keypoint format, 'mpii' or 'human36m'
            ignore_cameras:
                A list with indices of cameras to exclude (0 to 3 inclusive)
            dataset:
                Dataset, "h36m" or "TC"
        """
        assert train or test, '`Human36MMultiViewDataset` must be constructed with at least ' \
                              'one of `test=True` / `train=True`'
        assert kind in ("mpii", "human36m")

        self.joints_name = {
            0 : 'RFoot',
            1 : 'RKnee',
            2 : 'RHip',
            3 : 'LFoot',
            4 : 'LKnee',
            5 : 'LHip',
            6 : 'Spine',
            7 : 'Thorax',
            8 : 'Neck',
            9 : 'Head',
            10 : 'RShoulder',
            11 : 'RElbow',
            12 : 'RWrist',
            13 : 'LShoulder',
            14 : 'LElbow',
            15 : 'LWrist',
            16 : 'Nose'
        }

        self.h36m_root = h36m_root
        self.labels_path = labels_path
        self.image_shape = None if image_shape is None else tuple(image_shape)
        self.heatmape_shape = None if heatmap_shape is None else tuple(
            heatmap_shape)
        self.scale_bbox = scale_bbox
        self.norm_image = norm_image
        self.cuboid_side = cuboid_side
        self.kind = kind
        self.undistort_images = undistort_images
        self.ignore_cameras = ignore_cameras
        self.crop = crop
        self.action_target = action
        self.dataset = dataset
        self.rectificated=rectificated
        self.withsilhouette=withsilhouette
        self.depths_path = depths_label
        self.depthmaps_pthe = depthmaps_label

        self.labels = np.load(labels_path, allow_pickle=True).item()
        self.depths = np.load(depths_label, allow_pickle=True).item()
        
        n_cameras = len(self.labels['camera_names'])
        assert all(camera_idx in range(n_cameras)
                   for camera_idx in self.ignore_cameras)
        if dataset == "h36m":
            train_subjects = ['S1', 'S5', 'S6', 'S7', 'S8']
            test_subjects = ['S9', 'S11']
            train_subjects = list(self.labels['subject_names'].index(x)
                                  for x in train_subjects)
            test_subjects = list(self.labels['subject_names'].index(x)
                                 for x in test_subjects)

        else:
            train_subjects = ['1', '2', '3']
            test_subjects = ['1', '2', '3', '4', '5']
            if train:
                train_subjects = list(self.labels['subject_names'].index(x)
                                      for x in train_subjects)
            if test:
                test_subjects = list(self.labels['subject_names'].index(x)
                                     for x in test_subjects)

        indices = []
        if train:
            mask = np.isin(self.labels['table']['subject_idx'],
                           train_subjects,
                           assume_unique=True)
            indices.append(np.nonzero(mask)[0])
        if test:
            mask = np.isin(self.labels['table']['subject_idx'],
                           test_subjects,
                           assume_unique=True)

            if not with_damaged_actions:
                mask_S9 = self.labels['table']['subject_idx'] == self.labels[
                    'subject_names'].index('S9')

                damaged_actions = 'Greeting-2', 'SittingDown-2', 'Waiting-1'
                damaged_actions = [
                    self.labels['action_names'].index(x)
                    for x in damaged_actions
                ]
                mask_damaged_actions = np.isin(
                    self.labels['table']['action_idx'], damaged_actions)

                mask &= ~(mask_S9 & mask_damaged_actions)

            indices.append(
                np.nonzero(mask)[0][::retain_every_n_frames_in_test])

        self.labels['table'] = self.labels['table'][np.concatenate(indices)]

        self.num_keypoints = 16 if kind == "mpii" else 17
        assert self.labels['table']['keypoints'].shape[
            1] == 17, "Use a newer 'labels' file"

        self.keypoints_3d_pred = None
        if pred_results_path is not None:
            pred_results = np.load(pred_results_path, allow_pickle=True)
            keypoints_3d_pred = pred_results['keypoints_3d'][np.argsort(
                pred_results['indexes'])]
            self.keypoints_3d_pred = keypoints_3d_pred[::
                                                       retain_every_n_frames_in_test]
            assert len(self.keypoints_3d_pred) == len(self), \
                f"[train={train}, test={test}] {labels_path} has {len(self)} samples, but '{pred_results_path}' " + \
                f"has {len(self.keypoints_3d_pred)}. Did you follow all preprocessing instructions carefully?"

        _y, _x = torch.meshgrid(torch.arange(self.heatmape_shape[0]),
                                torch.arange(self.heatmape_shape[1]))
        grid = torch.stack([_x, _y], dim=-1)
        grid = grid
        self.grid = grid.view(-1, 2)

    def action_names_to_index_TC(self):
        return {
            'rom': 1,
            'walking': 2,
            'acting': 3,
            'running': 4,
            'freestyle': 5
        }

    def __len__(self):
        return len(self.labels['table'])

    def __getitem__(self, idx):
        sample = defaultdict(list)  # return value
        shot = self.labels['table'][idx]

        subject = self.labels['subject_names'][shot['subject_idx']]
        action = self.labels['action_names'][shot['action_idx']]
        frame_idx = shot['frame_idx']
        
        # depth load
        depth = self.depths[shot['subject_idx']][shot['action_idx']][frame_idx]
        
        keypoints_3d = np.pad(shot['keypoints'][:self.num_keypoints],
                                        ((0, 0), (0, 1)),
                                        'constant',
                                        constant_values=1.0)
        # print("action:", action)
        if self.action_target is not None and self.action_target not in action:
            # print("jump action:", action)
            return None
            # print("not jump action:", action)
        # vis = 1

        for camera_idx, camera_name in enumerate(self.labels['camera_names']):
            if camera_idx in self.ignore_cameras:
                continue

            # load bounding box
            bbox = shot['bbox_by_camera_tlbr'][camera_idx][[1, 0, 3,
                                                            2]]  # TLBR to LTRB
            # print("bbox:", bbox)
            # if bbox[0]<0 or bbox[1]<0 or bbox[2]<0 or bbox[3]<0:
            #     vis=0
            # elif bbox[1]>1080 or bbox[3]>1080 or bbox[0]>1920 or bbox[2]>1920 :
            #     vis=0
            bbox_height = bbox[2] - bbox[0]
            if bbox_height == 0:
                # convention: if the bbox is empty, then this view is missing
                continue

            # scale the bounding box
            bbox = scale_bbox(bbox, self.scale_bbox)

            # load image
            if self.dataset == "h36m":
                if self.rectificated:
                    image_path = os.path.join(
                        self.h36m_root, subject, action,
                        'imageSequence-rectificated' + '-undistorted' * self.undistort_images,
                        camera_name, 'img_%06d.jpg' % (frame_idx + 1))
                else:
                    image_path = os.path.join(
                        self.h36m_root, '_undistorted' * self.undistort_images, subject, action,
                        'imageSequence' + '-undistorted' * self.undistort_images,
                        camera_name, 'img_%06d.jpg' % (frame_idx + 1))
                if self.withsilhouette:
                    silhouette_path = os.path.join(
                        self.h36m_root, subject, action,
                        'imageSequence-silhouette' + '-croped',
                        camera_name, 'img_%06d.jpg' % (frame_idx + 1))
            else:
                action_name = action.split('-')
                action2idx = self.action_names_to_index_TC()
                image_path = os.path.join(
                    self.h36m_root, 'images',
                    's_{:0>2}_act_{:0>2}_subact_{:0>2}_ca_{:0>2}'.format(
                        int(subject), action2idx[action_name[0]],
                        int(action_name[1]),
                        int(camera_name)), '{:0>6}.jpg'.format(frame_idx))
            assert os.path.isfile(image_path), '%s doesn\'t exist' % image_path
            image = cv2.imread(image_path)
            if self.withsilhouette:
                silhouette = cv2.imread(silhouette_path, cv2.IMREAD_GRAYSCALE)
                silhouette = np.where(silhouette > 125, 1, 0).astype(float)
                # bbox_s = scale_bbox([0, 0, silhouette.shape[0]-1, silhouette.shape[1]-1], 1/1.5)
                # silhouette = crop_image(silhouette, bbox_s)
                # silhouette = resize_image(silhouette, (bbox_height, bbox_height))

            # load camera
            shot_camera = self.labels['cameras'][shot['subject_idx'],
                                                 camera_idx]
            # retval_camera = Camera(shot_camera['R'], shot_camera['t'],
            #                        shot_camera['K'], shot_camera['dist'],
            #                        camera_name)
            # aggeragation
            retval_camera = Camera(shot_camera['R'], shot_camera['T'],
                                   shot_camera['t'], shot_camera['K'],
                                   shot_camera['dist'], camera_name)
            # aggeragation
            cam_centor = np.array(shot_camera['T']).copy().reshape(1, 3)

            if self.crop:
                # crop image
                image = crop_image(image, bbox)
                retval_camera.update_after_crop(bbox)

            if self.image_shape is not None:
                # resize
                image_shape_before_resize = image.shape[:2]
                image = resize_image(image, self.image_shape)
                retval_camera.update_after_resize(image_shape_before_resize,
                                                  self.image_shape)
                if self.withsilhouette:
                    silhouette = resize_image(silhouette, self.heatmape_shape)
                    silhouette = np.where(silhouette>0.1, 1, 0.8).astype(float)

                sample['image_shapes_before_resize'].append(
                    image_shape_before_resize)

            if self.norm_image:
                image = normalize_image(image)

            # 3d keypoints in camera coordiate
            keypoints_3d_ca = retval_camera.extrinsics @ keypoints_3d[:,:,np.newaxis]
            # left, upper, right, lower = bbox
            # centor = np.array((0.5 * (left + right), 0.5 * (upper + lower)))
            # scale = np.array(((right - left) / 200.0, (lower - upper) / 200.0))
            # trans_inv = op.get_affine_transform(centor,
            #                                     scale,
            #                                     0,
            #                                     self.heatmape_shape,
            #                                     inv=1)  # (2, 3)

            # # (256/down * 256/down, 3)
            # coords_ray = op.create_3d_ray_coords(shot_camera, trans_inv,
            #                                      self.grid)

            # aggeragation
            # coords_img = np.zeros(
            #     (self.heatmape_shape[0], self.heatmape_shape[1], 2))
            # for h in range(self.heatmape_shape[0]):
            #     coords_img[h, :, 0] = np.arange(self.heatmape_shape[1]) + 0.5
            # for w in range(self.heatmape_shape[1]):
            #     coords_img[:, w, 1] = np.arange(self.heatmape_shape[0]) + 0.5
            # # print("coord_img:", coords_img)
            # coords_img[:, :,
            #            0] = coords_img[:, :, 0] * (self.image_shape[1] /
            #                                        self.heatmape_shape[1])
            # coords_img[:, :,
            #            1] = coords_img[:, :, 1] * (self.image_shape[0] /
            #                                        self.heatmape_shape[0])
            # # print("coord_img:", coords_img)
            # coords_img = torch.from_numpy(coords_img).float().reshape(
            #     1, 1, -1, 2)
            # camera_K = torch.from_numpy(retval_camera.getK).float().reshape(
            #     1, 1, 3, 3)
            # camera_R = torch.from_numpy(retval_camera.getR).float().reshape(
            #     1, 1, 3, 3)
            # camera_T = torch.from_numpy(retval_camera.getT).float().reshape(
            #     1, 1, 3, 1)
            # coords_ray = op.trans_3d_coords(coords_img, camera_K, camera_R,
            #                                 camera_T)
            # coords_ray = coords_ray.reshape(-1, 3)
            # coords_ray = coords_ray.numpy()
            # print("coords_ray:", coords_ray)
            # print("cam_entor:", cam_centor)

            # keypoints 2d
            keypoints_2d = multiview.project_3d_points_to_image_plane_without_distortion(
                retval_camera.projection, shot['keypoints'])
            # keypoints_2d[:, 0] = keypoints_2d[:, 0] / self.image_shape[0]
            # keypoints_2d[:, 1] = keypoints_2d[:, 1] / self.image_shape[1]

            sample['images'].append(image)
            if self.withsilhouette:
                sample['silhouettes'].append(silhouette)
            sample['detections'].append(bbox +
                                        (1.0, ))  # TODO add real confidences
            sample['cameras'].append(retval_camera)
            sample['proj_matrices'].append(retval_camera.projection)

            # aggeragation
            sample['cam_centor'].append(
                cam_centor)  # (1, 3) in world coordinate
            # sample['rays'].append(
            #     coords_ray)  # (heat_map_size, 3)  in world coordinate
            sample['keypoints_2d'].append(keypoints_2d)
            sample['keypoints_3d_ca'].append(keypoints_3d_ca)
        # 3D keypoints
        # add dummy confidences
        # if self.dataset=="h36m":
       
        sample['keypoints_3d'] = keypoints_3d
        sample['occlusion'] = np.zeros_like(shot['keypoints'][:self.num_keypoints])
        sample['keypoints_depth'] = np.array(depth).copy().reshape(17,1)
        # else:
        #     sample['keypoints_3d'] = np.pad(shot['keypoints'][:self.num_keypoints],
        #                                 ((0, 0), (0, 1)),
        #                                 'constant',
        #                                 constant_values=vis)

        # build cuboid
        # base_point = sample['keypoints_3d'][6, :3]
        # sides = np.array([self.cuboid_side, self.cuboid_side, self.cuboid_side])
        # position = base_point - sides / 2
        # sample['cuboids'] = volumetric.Cuboid3D(position, sides)

        # save sample's index
        sample['indexes'] = idx

        if self.keypoints_3d_pred is not None:
            sample['pred_keypoints_3d'] = self.keypoints_3d_pred[idx]

        sample.default_factory = None

        return sample

    def evaluate_using_per_pose_error(self, per_pose_error, split_by_subject):
        # print("pose_error.shape:", per_pose_error.shape)
        def evaluate_by_actions(self, per_pose_error, mask=None):
            if mask is None:
                mask = np.ones_like(per_pose_error, dtype=bool)

            action_scores = {
                'Average': {
                    'total_loss': per_pose_error[mask].sum(),
                    'frame_count': np.count_nonzero(mask)
                }
            }

            for action_idx in range(len(self.labels['action_names'])):
                action_mask = (self.labels['table']['action_idx']
                               == action_idx) & mask
                action_per_pose_error = per_pose_error[action_mask]
                action_scores[self.labels['action_names'][action_idx]] = {
                    'total_loss': action_per_pose_error.sum(),
                    'frame_count': len(action_per_pose_error)
                }

            action_names_without_trials = \
                [name[:-2] for name in self.labels['action_names'] if name.endswith('-1')]

            for action_name_without_trial in action_names_without_trials:
                combined_score = {'total_loss': 0.0, 'frame_count': 0}

                for trial in 1, 2:
                    action_name = '%s-%d' % (action_name_without_trial, trial)
                    combined_score['total_loss'] += action_scores[action_name][
                        'total_loss']
                    combined_score['frame_count'] += action_scores[
                        action_name]['frame_count']
                    del action_scores[action_name]

                action_scores[action_name_without_trial] = combined_score

            for k, v in action_scores.items():
                action_scores[k] = float('nan') if v['frame_count'] == 0 else (
                    v['total_loss'] / v['frame_count'])

            return action_scores

        subject_scores = {'Average': evaluate_by_actions(self, per_pose_error)}

        for subject_idx in range(len(self.labels['subject_names'])):
            subject_mask = self.labels['table']['subject_idx'] == subject_idx
            subject_scores[self.labels['subject_names'][subject_idx]] = \
                evaluate_by_actions(self, per_pose_error, subject_mask)

        return subject_scores

    def evaluate_TC(self,
                    keypoints_3d_predicted,
                    split_by_subject=False,
                    transfer_cmu_to_human36m=False,
                    transfer_human36m_to_human36m=False):
        keypoints_gt = self.labels['table']['keypoints'][:, :self.
                                                         num_keypoints]
        # mean error per 16/17 joints in mm, for each pose
        per_pose_error = np.sqrt(
            ((keypoints_gt - keypoints_3d_predicted)**2).sum(2)).mean(1)

        if not (transfer_cmu_to_human36m or transfer_human36m_to_human36m):
            root_index = 6 if self.kind == "mpii" else 6
        else:
            root_index = 0
        keypoints_gt_relative = keypoints_gt - keypoints_gt[:, root_index:
                                                            root_index + 1, :]
        keypoints_3d_predicted_relative = keypoints_3d_predicted - keypoints_3d_predicted[:,
                                                                                          root_index:
                                                                                          root_index
                                                                                          +
                                                                                          1, :]
        per_pose_error_relative = np.sqrt(
            ((keypoints_gt_relative -
              keypoints_3d_predicted_relative)**2).sum(2)).mean(1)

        result = {
            'per_pose_error':
            self.evaluate_using_per_pose_error(per_pose_error,
                                               split_by_subject),
            'per_pose_error_relative':
            self.evaluate_using_per_pose_error(per_pose_error_relative,
                                               split_by_subject)
        }

        return result['per_pose_error_relative']['Average']['Average'], result

    def evaluate(self,
                 keypoints_3d_predicted,
                 split_by_subject=False,
                 transfer_cmu_to_human36m=False,
                 transfer_human36m_to_human36m=False):
        keypoints_gt = self.labels['table']['keypoints'][:, :self.
                                                         num_keypoints]
        if keypoints_3d_predicted.shape != keypoints_gt.shape:
            raise ValueError(
                '`keypoints_3d_predicted` shape should be %s, got %s' % \
                (keypoints_gt.shape, keypoints_3d_predicted.shape))

        if transfer_cmu_to_human36m or transfer_human36m_to_human36m:
            human36m_joints = [10, 11, 15, 14, 1, 4]
            if transfer_human36m_to_human36m:
                cmu_joints = [10, 11, 15, 14, 1, 4]
            else:
                cmu_joints = [10, 8, 9, 7, 14, 13]

            keypoints_gt = keypoints_gt[:, human36m_joints]
            keypoints_3d_predicted = keypoints_3d_predicted[:, cmu_joints]

        # mean error per 16/17 joints in mm, for each pose
        per_pose_error = np.sqrt(
            ((keypoints_gt - keypoints_3d_predicted)**2).sum(2)).mean(1)
        # np.save('./res/mpjpe.npy', per_pose_error)
        # print(per_pose_error.shape)   # (samples, 1)
        # relative mean error per 16/17 joints in mm, for each pose
        if not (transfer_cmu_to_human36m or transfer_human36m_to_human36m):
            root_index = 6 if self.kind == "mpii" else 6
        else:
            root_index = 0

        keypoints_gt_relative = keypoints_gt - keypoints_gt[:, root_index:
                                                            root_index + 1, :]
        keypoints_3d_predicted_relative = keypoints_3d_predicted - keypoints_3d_predicted[:,
                                                                                          root_index:
                                                                                          root_index
                                                                                          +
                                                                                          1, :]

        per_pose_error_relative = np.sqrt(
            ((keypoints_gt_relative -
              keypoints_3d_predicted_relative)**2).sum(2)).mean(1)
        # np.save('./res/mpjpe_re.npy', per_pose_error_relative)
        # bone length mean error per 8/16 bone in mm for each pose
        skeleton_idx = [[6, 3], [6, 2], [2, 1], [3, 4], [1, 0], [4, 5], [6, 7],
                        [7, 8], [8, 9], [8, 12], [8, 13], [12, 11], [11, 10],
                        [13, 14], [14, 15]]
        trans_matric = np.zeros((17, len(skeleton_idx)))
        for g in range(len(skeleton_idx)):
            id1, id2 = skeleton_idx[g]
            trans_matric[id1, g] = 1
            trans_matric[id2, g] = -1
        bone_gt_x = keypoints_gt[:, :, 0] @ trans_matric
        bone_gt_y = keypoints_gt[:, :, 1] @ trans_matric
        bone_gt_z = keypoints_gt[:, :, 2] @ trans_matric
        bone_pred_x = keypoints_3d_predicted[:, :, 0] @ trans_matric
        bone_pred_y = keypoints_3d_predicted[:, :, 1] @ trans_matric
        bone_pred_z = keypoints_3d_predicted[:, :, 2] @ trans_matric
        # print("bone_gt_x.shape:", bone_gt_x.shape) #(smaples, bonenums)
        # KCS矩阵
        per_pose_bonelength_error = np.zeros_like(per_pose_error)
        for s in range(bone_gt_x.shape[0]):
            # print(s)
            bone_length_gt_x = bone_gt_x[s].reshape(
                -1, 1) @ bone_gt_x[s].reshape(-1, 1).T
            bone_length_gt_y = bone_gt_y[s].reshape(
                -1, 1) @ bone_gt_y[s].reshape(-1, 1).T
            bone_length_gt_z = bone_gt_z[s].reshape(
                -1, 1) @ bone_gt_z[s].reshape(-1, 1).T
            bone_length_pred_x = bone_pred_x[s].reshape(
                -1, 1) @ bone_pred_x[s].reshape(-1, 1).T
            bone_length_pred_y = bone_pred_y[s].reshape(
                -1, 1) @ bone_pred_y[s].reshape(-1, 1).T
            bone_length_pred_z = bone_pred_z[s].reshape(
                -1, 1) @ bone_pred_z[s].reshape(-1, 1).T
            # print("bone_length_gt_x:", bone_length_gt_x.shape) #(bonenums, bonenums)
            bone_error = 0
            for i in range(bone_length_gt_x.shape[0]):
                bone_length_gt = np.sqrt(bone_length_gt_x[i, i] +
                                         bone_length_gt_y[i, i] +
                                         bone_length_gt_z[i, i])
                bone_length_pred = np.sqrt(bone_length_pred_x[i, i] +
                                           bone_length_pred_y[i, i] +
                                           bone_length_pred_z[i, i])
                # print("bonelength:", bone_length_gt, bone_length_pred)
                bone_error += abs(bone_length_gt - bone_length_pred)
            per_pose_bonelength_error[s] = bone_error / len(skeleton_idx)
        # print("per_pose_bonelength_error.shape:",
            #   per_pose_bonelength_error.shape)
        # print("per_pose_error.shape:", per_pose_error.shape)
        # print("per_pose_error_relative.shape:", per_pose_error_relative.shape)

        result = {
            'per_pose_bonelength_error':
            self.evaluate_using_per_pose_error(per_pose_bonelength_error,
                                               split_by_subject),
            'per_pose_error':
            self.evaluate_using_per_pose_error(per_pose_error,
                                               split_by_subject),
            'per_pose_error_relative':
            self.evaluate_using_per_pose_error(per_pose_error_relative,
                                               split_by_subject)
        }

        return result['per_pose_error_relative']['Average'][
            'Average'], result['per_pose_error']['Average'][
            'Average'], result

    def evaluate_reasonbale(self,
                            keypoints_3d_predicted,
                            split_by_subject=False,
                            transfer_cmu_to_human36m=False,
                            transfer_human36m_to_human36m=False,
                            occupany_matrix=None):
        '''[evaluate the reasonability of pose]

        Args:
            keypoints_3d_predicted ([numpy(B, N, 3)]): [3d keypoints predicted]
            split_by_subject (bool, optional): [description]. Defaults to False.
            transfer_cmu_to_human36m (bool, optional): [description]. Defaults to False.
            transfer_human36m_to_human36m (bool, optional): [description]. Defaults to False.
            occupany_matrix ([numpy(K, 181, 361)], optional): [occupany matrix of joint_angle]. Defaults to None.

        Raises:
            ValueError: [description]

        Returns:
            [type]: [description]
        '''
        keypoints_gt = self.labels['table']['keypoints'][:, :self.
                                                         num_keypoints]
        if keypoints_3d_predicted.shape != keypoints_gt.shape:
            raise ValueError('`keypoints_3d_predicted` shape should be %s, got %s' % \
                (keypoints_gt.shape, keypoints_3d_predicted.shape))

        if transfer_cmu_to_human36m or transfer_human36m_to_human36m:
            human36m_joints = [10, 11, 15, 14, 1, 4]
            if transfer_human36m_to_human36m:
                cmu_joints = [10, 11, 15, 14, 1, 4]
            else:
                cmu_joints = [10, 8, 9, 7, 14, 13]

            keypoints_gt = keypoints_gt[:, human36m_joints]
            keypoints_3d_predicted = keypoints_3d_predicted[:, cmu_joints]

        # mean error per 16/17 joints in mm, for each pose
        per_pose_error = np.sqrt(
            ((keypoints_gt - keypoints_3d_predicted)**2).sum(2)).mean(1)
        # print(per_pose_error.shape)   # (samples, 1)
        # relative mean error per 16/17 joints in mm, for each pose
        if not (transfer_cmu_to_human36m or transfer_human36m_to_human36m):
            root_index = 6 if self.kind == "mpii" else 6
        else:
            root_index = 0

        keypoints_gt_relative = keypoints_gt - keypoints_gt[:, root_index:
                                                            root_index + 1, :]
        keypoints_3d_predicted_relative = keypoints_3d_predicted - keypoints_3d_predicted[:,
                                                                                          root_index:
                                                                                          root_index
                                                                                          +
                                                                                          1, :]

        # reasonable evaluate
        # bone length
        sample_nums = keypoints_3d_predicted.shape[0]
        bl_propor_reason_1 = np.zeros_like(per_pose_error)
        bl_propor_reason_2 = np.zeros_like(per_pose_error)
        bl_propor_reason_3 = np.zeros_like(per_pose_error)
        bl_propor_reason_4 = np.zeros_like(per_pose_error)
        bl_propor_reason_5 = np.zeros_like(per_pose_error)
        bl_bone_propor_reason_1 = np.zeros_like(per_pose_error)
        bl_bone_propor_reason_2 = np.zeros_like(per_pose_error)
        bl_bone_propor_reason_3 = np.zeros_like(per_pose_error)
        bl_bone_propor_reason_4 = np.zeros_like(per_pose_error)
        bl_bone_propor_reason_5 = np.zeros_like(per_pose_error)

        for sample_i in range(sample_nums):
            keypoint_gt = np.expand_dims(keypoints_gt_relative[sample_i],
                                         axis=0)
            keypoint_pred = np.expand_dims(
                keypoints_3d_predicted_relative[sample_i], axis=0)
            body_gt = body_kinematic.Body_Kinematic(keypoint_gt)
            body_pred = body_kinematic.Body_Kinematic(keypoint_pred)
            bl_gt = body_gt.keypoints2bone()
            bl_gt = body_gt.bone_length_mean(bl_gt)
            # print("bl_gt.shape:", bl_gt.shape)
            bl_res = body_pred.bl_eva(bl_gt, 0.1)
            bl_propor_reason_1[sample_i], bl_bone_propor_reason_1[
                sample_i] = bl_res[0][0], bl_res[1][0]
            bl_res = body_pred.bl_eva(bl_gt, 0.2)
            bl_propor_reason_2[sample_i], bl_bone_propor_reason_2[
                sample_i] = bl_res[0][0], bl_res[1][0]
            bl_res = body_pred.bl_eva(bl_gt, 0.3)
            bl_propor_reason_3[sample_i], bl_bone_propor_reason_2[
                sample_i] = bl_res[0][0], bl_res[1][0]
            bl_res = body_pred.bl_eva(bl_gt, 0.4)
            bl_propor_reason_4[sample_i], bl_bone_propor_reason_2[
                sample_i] = bl_res[0][0], bl_res[1][0]
            bl_res = body_pred.bl_eva(bl_gt, 0.5)
            bl_propor_reason_5[sample_i], bl_bone_propor_reason_2[
                sample_i] = bl_res[0][0], bl_res[1][0]
        # print("bl_propor_reason_1.shape:", bl_propor_reason_1.shape)

        #joint angle
        body_pred = body_kinematic.Body_Kinematic(
            keypoints_3d_predicted_relative)
        # occupany_matrix = np.load("./resnb_data/occupany_matrix.npy")
        ja_res = body_pred.angle_eva(occupany_matrix)
        joint_angle_reason, joint_angle_pjoint_reason = ja_res[0].squeeze(
            1), ja_res[1].squeeze(1)
        # print("joint_angle_reason.shape:", joint_angle_reason.shape)

        #all
        all_reason_1 = np.zeros_like(per_pose_error)
        all_reason_2 = np.zeros_like(per_pose_error)
        all_reason_3 = np.zeros_like(per_pose_error)
        all_reason_4 = np.zeros_like(per_pose_error)
        all_reason_5 = np.zeros_like(per_pose_error)
        for i, x in enumerate(joint_angle_reason):
            if (x == 1 and bl_propor_reason_1[i] == 1):
                all_reason_1[i] = 1
            if (x == 1 and bl_propor_reason_2[i] == 1):
                all_reason_2[i] = 1
            if (x == 1 and bl_propor_reason_3[i] == 1):
                all_reason_3[i] = 1
            if (x == 1 and bl_propor_reason_4[i] == 1):
                all_reason_4[i] = 1
            if (x == 1 and bl_propor_reason_5[i] == 1):
                all_reason_5[i] = 1
        # print("all_reason_1.shape:", all_reason_1.shape)

        result = {
            'reasonable_1':
            self.evaluate_using_per_pose_error(all_reason_1, split_by_subject),
            'reasonable_2':
            self.evaluate_using_per_pose_error(all_reason_2, split_by_subject),
            'reasonable_3':
            self.evaluate_using_per_pose_error(all_reason_3, split_by_subject),
            'reasonable_4':
            self.evaluate_using_per_pose_error(all_reason_4, split_by_subject),
            'reasonable_5':
            self.evaluate_using_per_pose_error(all_reason_5, split_by_subject),
            'bl_reasonable_1':
            self.evaluate_using_per_pose_error(bl_propor_reason_1,
                                               split_by_subject),
            'bl_reasonable_2':
            self.evaluate_using_per_pose_error(bl_propor_reason_2,
                                               split_by_subject),
            'bl_bone_reasonable_1':
            self.evaluate_using_per_pose_error(bl_bone_propor_reason_1,
                                               split_by_subject),
            'bl_bone_reasonable_2':
            self.evaluate_using_per_pose_error(bl_bone_propor_reason_2,
                                               split_by_subject),
            'joint_angle_reason':
            self.evaluate_using_per_pose_error(joint_angle_reason,
                                               split_by_subject),
            'joint_angle_pjoint_reason':
            self.evaluate_using_per_pose_error(joint_angle_pjoint_reason,
                                               split_by_subject)
        }

        return result['reasonable_2']['Average'][
            'Average'], result, bl_propor_reason_2, joint_angle_reason, all_reason_2

    def evaluate_split_by_joints(self,
                                 keypoints_3d_predicted,
                                 split_by_subject=False,
                                 transfer_cmu_to_human36m=False,
                                 transfer_human36m_to_human36m=False,
                                 keypoints_gt=None):
        if keypoints_gt is None:
            keypoints_gt = self.labels['table']['keypoints'][:, :self.
                                                             num_keypoints]
        if keypoints_3d_predicted.shape != keypoints_gt.shape:
            raise ValueError(
                '`keypoints_3d_predicted` shape should be %s, got %s' % \
                (keypoints_gt.shape, keypoints_3d_predicted.shape))

        if transfer_cmu_to_human36m or transfer_human36m_to_human36m:
            human36m_joints = [10, 11, 15, 14, 1, 4]
            if transfer_human36m_to_human36m:
                cmu_joints = [10, 11, 15, 14, 1, 4]
            else:
                cmu_joints = [10, 8, 9, 7, 14, 13]

            keypoints_gt = keypoints_gt[:, human36m_joints]
            keypoints_3d_predicted = keypoints_3d_predicted[:, cmu_joints]

        # mean error each joint in mm, for each pose
        per_pose_error = np.sqrt(
            ((keypoints_gt - keypoints_3d_predicted)**2).sum(2))
        # print("per_pose_error:", per_pose_error.shape)
        # print(per_pose_error.shape)   # (samples, joints, 1)
        # relative mean error per 16/17 joints in mm, for each pose
        if not (transfer_cmu_to_human36m or transfer_human36m_to_human36m):
            root_index = 6 if self.kind == "mpii" else 6
        else:
            root_index = 0

        keypoints_gt_relative = keypoints_gt - keypoints_gt[:, root_index:
                                                            root_index + 1, :]
        keypoints_3d_predicted_relative = keypoints_3d_predicted - keypoints_3d_predicted[:,
                                                                                          root_index:
                                                                                          root_index
                                                                                          +
                                                                                          1, :]

        per_pose_error_relative = np.sqrt(
            ((keypoints_gt_relative -
              keypoints_3d_predicted_relative)**2).sum(2))
        # print("per_pose_error_relative:", per_pose_error_relative.shape)

        # bone length mean error per 16 bone in mm for each pose
        skeleton_idx = [[6, 3], [6, 2], [2, 1], [3, 4], [1, 0], [4, 5], [6, 7],
                        [7, 8], [8, 9], [8, 12], [8, 13], [12, 11], [11, 10],
                        [13, 14], [14, 15]]
        trans_matric = np.zeros((17, len(skeleton_idx)))
        for g in range(len(skeleton_idx)):
            id1, id2 = skeleton_idx[g]
            trans_matric[id1, g] = 1
            trans_matric[id2, g] = -1
        bone_gt_x = keypoints_gt[:, :, 0] @ trans_matric
        bone_gt_y = keypoints_gt[:, :, 1] @ trans_matric
        bone_gt_z = keypoints_gt[:, :, 2] @ trans_matric
        bone_pred_x = keypoints_3d_predicted[:, :, 0] @ trans_matric
        bone_pred_y = keypoints_3d_predicted[:, :, 1] @ trans_matric
        bone_pred_z = keypoints_3d_predicted[:, :, 2] @ trans_matric
        # print("bone_gt_x.shape:", bone_gt_x.shape) #(smaples, bonenums)
        # KCS矩阵
        per_pose_bonelength_error = np.zeros_like(per_pose_error)
        for s in range(bone_gt_x.shape[0]):
            # print(s)
            bone_length_gt_x = bone_gt_x[s].reshape(
                -1, 1) @ bone_gt_x[s].reshape(-1, 1).T
            bone_length_gt_y = bone_gt_y[s].reshape(
                -1, 1) @ bone_gt_y[s].reshape(-1, 1).T
            bone_length_gt_z = bone_gt_z[s].reshape(
                -1, 1) @ bone_gt_z[s].reshape(-1, 1).T
            bone_length_pred_x = bone_pred_x[s].reshape(
                -1, 1) @ bone_pred_x[s].reshape(-1, 1).T
            bone_length_pred_y = bone_pred_y[s].reshape(
                -1, 1) @ bone_pred_y[s].reshape(-1, 1).T
            bone_length_pred_z = bone_pred_z[s].reshape(
                -1, 1) @ bone_pred_z[s].reshape(-1, 1).T
            # print("bone_length_gt_x:", bone_length_gt_x.shape) #(bonenums, bonenums)
            bone_error = 0
            for i in range(bone_length_gt_x.shape[0]):
                bone_length_gt = np.sqrt(bone_length_gt_x[i, i] +
                                         bone_length_gt_y[i, i] +
                                         bone_length_gt_z[i, i])
                bone_length_pred = np.sqrt(bone_length_pred_x[i, i] +
                                           bone_length_pred_y[i, i] +
                                           bone_length_pred_z[i, i])
                # print("bonelength:", bone_length_gt, bone_length_pred)
                bone_error = abs(bone_length_gt - bone_length_pred)
                per_pose_bonelength_error[s, i] = bone_error
        # print("per_pose_bonelength_error:", per_pose_bonelength_error.shape)

        n_joints = keypoints_gt.shape[-2]
        result = dict()
        result_relative = dict()
        for n_joint in range(n_joints):
            result[n_joint] = self.evaluate_using_per_pose_error(
                per_pose_error[:, n_joint], split_by_subject)
            result_relative[n_joint] = self.evaluate_using_per_pose_error(
                per_pose_error_relative[:, n_joint], split_by_subject)
        # print("result:", result)
        # print("result_re:", result_relative)

        result_bonelength = dict()
        for n_joint in range(n_joints):
            result_bonelength[n_joint] = self.evaluate_using_per_pose_error(
                per_pose_bonelength_error[:, n_joint], split_by_subject)
        # print("result_bone:", result_bonelength)

        return result, result_relative, result_bonelength
    
    def JDR_2d(self, keypoints_2d_pred, keypoints_2d_gt):
        pred = keypoints_2d_pred.copy().reshape(-1,17,2)
        gt = keypoints_2d_gt.copy().reshape(-1,17,2)

        headsize = self.image_shape[0] / 10.0
        threshold = 0.5

        distance = np.sqrt(np.sum((gt - pred)**2, axis=2))
        detected = (distance <= headsize * threshold)

        joint_detection_rate = np.sum(detected, axis=0) / np.float(gt.shape[0])

        name_values = {}
        joint_names = self.joints_name
        for i in range(len(joint_names)):
            name_values[joint_names[i]] = joint_detection_rate[i]
        name_values["avg"] = np.mean(joint_detection_rate)
        return name_values, np.mean(joint_detection_rate)
